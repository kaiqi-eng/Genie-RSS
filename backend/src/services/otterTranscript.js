import { ChatOpenAI } from "@langchain/openai";
import { HumanMessage } from "@langchain/core/messages";
import { createLogger } from "../utils/logger.js";

const logger = createLogger('services:otterTranscript');

if (!process.env.OPENAI_API_KEY) {
  throw new Error("OPENAI_API_KEY is missing");
}

const llm = new ChatOpenAI({
  model: "gpt-3.5-turbo-0125",
  temperature: 0,
  apiKey: process.env.OPENAI_API_KEY,
});

/**
 * Clean Slack/Otter transcript text for prompt
 * Removes raw line breaks and excessive whitespace
 */
function cleanTranscript(text) {
  if (!text) return "";
  return text
    .replace(/[\r\n]+/g, " ")  // convert newlines to spaces
    .replace(/\t/g, " ")       // remove tabs
    .trim();
}

/**
 * Escape quotes inside JSON strings
 */
function escapeJSONString(str) {
  if (!str) return "";
  return str
    .replace(/\\/g, "\\\\")
    .replace(/"/g, '\\"')
    .replace(/\r?\n/g, "\\n")
    .replace(/\t/g, "\\t")
    .replace(/[\u0000-\u001F]+/g, " ")
    .trim();
}

/**
 * Extract first JSON object/array from string
 */
function extractJSON(str) {
  const match = str.match(/\{[\s\S]*\}|\[[\s\S]*\]/);
  if (!match) throw new Error("No JSON object found in LLM output");
  return JSON.parse(match[0]);
}

/**
 * Build structured JSON-only prompt for combined transcripts
 */
function buildPrompt(feeds) {
  const combinedText = feeds
    .map((f, i) => {
      const content = typeof f === "string" ? f : f.content || "";
      return `${i + 1}.\n${cleanTranscript(content)}`;
    })
    .join("\n\n");

  return `
You are a senior operations intelligence analyst reviewing internal meeting transcripts generated by Otter.ai.

Your task is to analyze ALL transcripts together and return valid JSON ONLY.

Instructions:
1. Write a single concise executive summary (3â€“4 sentences) for all transcripts.
2. Extract key_themes, important_developments, and risks_or_opportunities (arrays).
3. Determine if PAYABLE work occurred (true/false) with evidence and confidence.
4. PAYABLE work means active technical implementation, system configuration, writing code, integration, or operational execution.
5. Do NOT include markdown, commentary, or any text outside JSON.
6. Escape quotes inside strings, and do NOT include raw line breaks or tabs in string values.
7. Your response must parse with JSON.parse().

Required JSON format:

{
  "items": [
    {
      "summary": "",
      "key_themes": [],
      "important_developments": [],
      "risks_or_opportunities": [],
      "payable_work_validation": {
        "payable_work_done": false,
        "payable_work_evidence": "",
        "confidence": ""
      }
    }
  ]
}

Transcripts:
${combinedText}
`;
}

/**
 * Summarize and validate Otter.ai transcripts as a single combined item
 */
export async function summarizeTranscript(feeds) {
  if (!Array.isArray(feeds) || feeds.length === 0) {
    throw new Error("feeds must be a non-empty array");
  }

  const prompt = buildPrompt(feeds);

  let response;
  try {
    response = await llm.invoke([new HumanMessage(prompt)]);
  } catch (err) {
    throw new Error("LLM request failed: " + err.message);
  }

  let parsed;
  try {
    parsed = extractJSON(response.content);

    if (!Array.isArray(parsed.items)) {
      parsed.items = [parsed.items].filter(Boolean);
    }
  } catch (err) {
    logger.error('Invalid JSON from LLM', { content: response.content, error: err });
    throw new Error("LLM returned invalid JSON");
  }

  // Return a single item combining all transcript content
  return {
    total_feeds: feeds.length,
    items: [
      {
        title: "", // optional combined title
        source: "otter.ai",
        published: "",
        content: feeds.map(f => (typeof f === "string" ? f : f.content || "")).join("\n\n"),
        summary: parsed.items[0].summary || "No summary generated",
        key_themes: Array.isArray(parsed.items[0].key_themes) ? parsed.items[0].key_themes : [],
        important_developments: Array.isArray(parsed.items[0].important_developments)
          ? parsed.items[0].important_developments
          : [],
        risks_or_opportunities: Array.isArray(parsed.items[0].risks_or_opportunities)
          ? parsed.items[0].risks_or_opportunities
          : [],
        payable_work_validation: {
          payable_work_done: parsed.items[0].payable_work_validation?.payable_work_done === true,
          payable_work_evidence: parsed.items[0].payable_work_validation?.payable_work_evidence || "",
          confidence: parsed.items[0].payable_work_validation?.confidence || "low",
        },
      }
    ],
  };
}
